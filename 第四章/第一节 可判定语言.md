

#### 4.1.1 与正则语言相关的可判定性问题

**DFA接受问题** ：检测一个特定的确定型有穷自动机是否接受一个事先给定的串，此问题可表示为语言$A_{DFA}$，它包含了所有$DFA$的编码以及$DFA$接受的串的编码。令
             $A_{DFA} = \{{\left \langle B , w\right \rangle}|B 是DFA并且接受输入串w\}$
问题"DFA  B是否接受输入$w$" 与问题“ $\left \langle B, w \right \rangle$ 是否是$A_{DFA}$的元素”是相同的。

**定理 4.1** $A_{DFA} 是一个可判定语言。$
**证明** 设计一个判定$A_{DFA}$的图灵机$M$：
$M$= “对于输入$\left \langle B , w  \right \rangle$，其中$B$是$DFA$，$w$是串：GAM
    1.在输入$w$上模拟$B$。
    2.如果模拟以接受状态结束，则$接受$；如果以非接受状态结束，则$拒绝$。”
首先检查输入$\left \langle B, w\right \rangle$，它表示输入串$w$和DFA B。B的一个合理的表示方式是简单地列出它的五个元素$Q, \ \Sigma , \ \delta , q_0$ 及$F$。当$M$收到这个输入时，首先检查它是否正确地表示了DFA B和串$w$。如果不是，则拒绝。

然后$M$直接执行模拟，用在带子上写下信息的方法，它可以记录$B$在输入$w$上运行时的当前状态和当前位置。运行开始时，$B$是当前状态是$q_0$，读写头的当前位置是$w$的最左端符号。状态和位置的更新是由转移函数$\delta$决定的。当$M$处理完$w$的最后一个符号时，如果$B$处于接受状态，则$M$结束这个输入；如果不是，则$M$拒绝。

**定理 4.2** $A_{NFA}是一个可判定语言。(A_{NFA} = \{\left \langle B, w \right \rangle | B是NFA并且接受输入串w\})$

**证明** 可以直接仿照$M$设计$N$，也可以用$M$作为$N$的子程序。因为$M$被设计成只接受DFA作为输入，故N先将作为输入所收到的NFA转换成DFA，然后再将它传给$M$。


**定理4.3** $A_{REX} 是一个可判定语言(A_{REX} = \{\left \langle R, w \right \rangle | R是正则表达式，w是串，R派生w\})。$
**证明** 与上述证明类似，将正则表达式转换成一个与之等价的NFA A。

**定理 4.4** $E_{DFA}是一个可判定语言(E_{DFA} = \{\left \langle A \right \rangle | A是一个DFA,且L(A) = \varnothing \}。$
**证明** 设计图灵机$T$ 
$T$ = “ 对于输入$\left \langle A \right \rangle$，其中$A$是一个$DFA$：
     1.标记$A$的起始状态；
     2.重复下列步骤，直到所有状态都被标记。
     3.对于一个状态，如果有一个到达它的转移是从某个已经标记过的状态出发的，则将其标记；
     4.如果没有接受状态被标记，则$接受$，否则$拒绝$。


**定理 4.5** $EQ_{DFA} 是一个可判定语言(EQ_{DFA} = \{\left \langle A, B \right \rangle | A和B都是DFA，且L(A) = L(B)\}。$

**证明** 

