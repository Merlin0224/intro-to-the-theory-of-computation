
#### 2.2.1 下推自动机的形式化定义

**定义 2.8** **下推自动机**是6元组$(Q, \Sigma, \Gamma, \delta, q_0, F)$，这里$Q, \Sigma, \Gamma$和$F$都是有穷集合，并且
$1.$$Q$是状态集。
$2.$$\Sigma$设计输入字母表。
$3.$$\Gamma$是栈字母表。
$4.$$\delta \ :  \ Q \times \Sigma \times \Gamma \rightarrow \mathcal{P}(Q \times \Gamma_\varepsilon)$是转移函数。
$5.$$q_0 \in Q$是起始状态。
$6.$$F \subseteq Q$是接受状态。


#### 2.2.3 与上下文无关文法的等价性

**定理 2.12** $一个语言是上下文无关的，当且仅当存在一台下推自动机识别它。$

**引理 2.13** $如果一个语言是上下文无关的，则存在一台下推自动机识别它。$
**证明思路** ：
$P$的非形式化描述如下：
$1.$把标记符$\$$和起始变元放入栈中。
$2.$重复下述步骤：
$a.$如果栈顶是变元$A$，则非确定地选择一个关于$A$的规则，并且把$A$替换成这条规则右边的字符串。
$b.$如果栈顶是终结符$a$，则读取下一个输入符号，并且把它与$a$进行比较。如果它们匹配，则重复，如果它们不匹配，则这个非确定性分支拒绝。
$c.$如果栈顶是符号$\$$，则进入接受状态，如果此刻输入已全部读完，则接受这个输入串。
**证明** 设$q$和$r$是$PDA$的状态，$a$属于$\Sigma_{\varepsilon}$，$s$属于$\Gamma_{\varepsilon}$。我们要求$PDA$读$a$并且弹出$s$时，从$q$到$r$，而且要它同时把整个字符串$u=u_1\cdots u_l$推入栈。可以如下完成这个动作：引入新的状态$q_1,\cdots, q_{l-1}$，并且令转移函数如下：
                     $\delta(q, a, s)$包含$(q_1, u_l)$
                     $\delta(q_1, \varepsilon, \varepsilon) = \{(q_2, u_{l-1})\}$
                     $\delta(q_2, \varepsilon, \varepsilon) = \{(q_3, u_{l-2})\}$
                            $\vdots$
                     $\delta(q_{l-1}, \varepsilon, \varepsilon) = \{(r, u_1)\}$
使用记号$(r, u) \in \delta(q, a, s)$，表示当$q$是$P$的状态，$a$是下一个输入符号以及$s$是栈顶符号时，$PDA \ P$能够读$a$和弹出$s$，然后把字符串$u$推入栈和转移到状态$r$。
$P$的状态集$Q=\{q_{start}, q_{loop}, q_{accept} \} \cup E$，这里$E$时实现刚才描述的缩写所需要的状态集合，开始状态为$q_{start}$,只有一个接受状态$q_{accept}$。
转移函数定义如下。从初始化栈开始，把符号$\$$ 和$S$推入栈，实现步骤1的非形式化描述是：$\delta(q_{start}, \varepsilon, \varepsilon) = \{(q_{loop}, S\$)\}$，然后进行步骤2主循环中的转移。
首先，处理情况$(a)$，这时栈顶是一个变元。令$\delta(q_{start}, \varepsilon, A) = \{(q_{loop}, w) | A \rightarrow w 是R中的一条规则\}$。
其次，处理情况$(b)$，这时栈顶是一个终结符。令$\delta(q_{loop}, a, a)= \{(q_{loop}, \varepsilon)\}$。
最后，处理情况$(c)$，这时栈顶是空栈标记符$\$$。令$\delta(q_{loop}, \varepsilon, \$) = \{(q_{accept}, \varepsilon)\}$。

**引理 2.15** $如果一个语言被一台下推自动机识别，则它是上下文无关的。$
**证明** 设$P=\{Q, \Sigma, \Gamma, \delta, q_0,\{q_{accept}\} \}$，要构造$G$，$G$的变元集是$\{A_{pq} | p , q \in Q \}$，起始变元是$A_{q_0, q_accept}$。下面三点描述了$G$的规则：r, u
$1$对每一个$p, q, r, s \in Q, u \in \Gamma$和$a, b \in \Sigma_{\varepsilon}$，如果$\delta(p, a, \varepsilon)$包含$(r, u)$且$\delta(s, b, u)$包含$(q, \varepsilon)$，则把规则$A\rightarrow aA_{rs}b$放入$G$中。
$2.$对每一个$p, q, r \in Q$，把规则$A_{pq} \rightarrow A_{pr}A_{rq}$放入$G$中。
$3.$最后，对每一个$p \in Q$，把规则$A_{pp} \rightarrow \varepsilon$放入$G$中。
可以从如下两个图中获得一些关于这个构造的直觉：
![300](326a86a89d544ef641d823b975d0cf40.jpg)
下面证明$A_{pq}$产生$x$当且仅当$x$能够把$P$从状态$p$和空栈一块带到状态$q$和空栈，从而证明上述构造是正确的。

**2.16** $如果A_{pq} 产生x，则x能够把P从p和空栈一块带到q和空栈。$

**归纳基础** 派生只有一步。
只有一步的派生一定使用一条右端不含变元的规则。在G中右端不出现变元的规则只能是$A_{pp} \rightarrow \varepsilon$。显然，输入$varepsilon$把$P$从$p$和空栈带到$p$和空栈，从而证明了归纳基础。

**归纳步骤** 假设断言对长度不超过$k$的派生成立，其中$k \geq1$，下面证明断言第长度为$k+1$的派生也成立。
假设$A \xRightarrow{*} x$使用$k+1$步。该派生的第一步是$A_{pq} \Rightarrow aA_{rs}b$或$A_{pq} \Rightarrow A_{pr}A_{rq}$，分别处理这两种情况。
对于第一种情况，根据$x$中由$A_{rs}$产生的部分$y$，有$x = ayb$，因为$A_{rs} \xRightarrow{*} y$使用$k$步，根据归纳假设，$P$能够从$r$和空栈一块转移到$s$和空栈。因为$A_{pq} \rightarrow aA_{rs}b$是$G$的一条规则，故对某个栈符号$G, \delta(p, a, \varepsilon)$包含$(r, u)$和$\delta(s, b, u)$包含$(q, \varepsilon)$。于是，如果$P$从状态$p$和空栈开始，那么在读到$a$后，它能够转移到状态$r$，并且把$u$推入栈顶。然后读$y$，把它带到$s$，并且在栈中留下$u$。接着在读到$b$后，它能够转移到$q$，并且把$u$弹出栈。因此，$x$能够把$P$从$p$和空栈带到$q$和空栈。
对于第二种情况，根据$x$中由$A_{pr}$和$A_{pq}$分别产生的部分$y$和$z$，有$x = yz$。因为$A_{pr} \xRightarrow{*} y$和$A_{rq} \xRightarrow z$都不超过$k$步，根据归纳假设，$y$能够把$P$从$p$带到$r$，$z$能够把$P$从$r$带到$q$，并且在派生的开始和结束时都是空栈。因此，$x$能够把$P$从$p$和空栈带到$q$和空栈。这就完成了归纳步骤。

**断言 2.17** $如果x能够把P从p和空栈带到q和空栈，那么A_{pq}产生x。$

通过对输入$x$，$P$从$p$和空栈到$q$和空栈的计算步数作归纳，来证明这个断言。
**归纳基础** 计算有$0$步。
如果计算有$0$步，则它开始和结束在同一个状态，比如说是$p$。因此，我们要证明$A_{pp} \xRightarrow {*}x$。在$0$步内，$P$无法读入任何字符，故$x= \varepsilon$。根据$G$的构造，他又规则$A_{pp} \rightarrow \varepsilon$，这就证明了归纳基础。

**归纳步骤** 假设断言对长度不超过$k$的计算成立，其中$k \geq 0$，要证明断言对长度为$k+1$的计算也成立。
假设$P$有一个计算，在$k+1$步内$x$把$p$连同空栈一块带到$q$，或者仅在计算的开始和结束时栈是空的，或者在其他某个地方栈也变成空的。
对于第一种情况，第一步推入栈的符号一定和最后一步弹出栈的符号相同，把这个符号称为$u$。设$a$是第一步读的输入符号，$b$是最后一步读的输入符号，$r$是第一步后的状态，$s$是最后一步之前的状态，那么，$\delta(p, a, \varepsilon)$包含$(r, u)$且$\delta(s, b, u)$包含$(q, \varepsilon)$，从而在$G$中有规则$A_{pq} \rightarrow aA_{rs}b$。
令$y$是$x$中不包括$a$和$b$在内的部分，即$x=ayb$，输入$y$能够把$P$从$r$带到$s$而不触及栈底的符号$u$，从而$P$能够在输入$y$上连同空栈一块从$r$转移到$s$。由于已经从原来关于$x$的计算中删去第一步和最后一步，故关于$y$的计算有$(k+1) - 2 = k - 1$步，于是，根据归纳假设有$A_{pq} \rightarrow aA_{rs}b$。
对于第二种情况，设$r$是关于$x$的计算中除开始和结束之外站变成空的时候的状态，于是，计算从$p$到$r$和从$r$到$q$的部分都不超过$k$步，记$y$为计算前一部分读的输入，$z$为后一部分读的输入，根据归纳假设有$A_{pr} \xRightarrow{*} y$和$A_{rq} \xRightarrow{*} z$。由于$G$中有规则$A_{pq} \rightarrow A_{pr}A_{rq}$，故$A_{pq} \xRightarrow {*} x$，证毕。

**推论 2.18** $每一个正则语言都是上下文无关的。$
